diff --git a/test-jwt-exploit.js b/test-jwt-exploit.js
new file mode 100644
index 0000000..6463806

/**
 * Test script to verify JWT hardcoded fallback secret vulnerability is fixed
 * 
 * The vulnerability exists if:
 * 1. The application allows generating/verifying tokens using "fallback-secret"
 * 2. The application doesn't validate JWT_SECRET environment variable
 * 
 * The vulnerability is FIXED if:
 * 1. The application throws an error on startup if JWT_SECRET is not set
 * 2. The application throws an error on startup if JWT_SECRET is less than 32 chars
 * 3. The application validates JWT_SECRET in the auth module
 */

const jwt = require('jsonwebtoken');
const fs = require('fs');
const path = require('path');

console.log("[*] Testing JWT Hardcoded Fallback Secret Vulnerability\n");

// Test 1: Check if the source code still contains the fallback
console.log("[TEST 1] Checking if source code contains hardcoded fallback secret...");
const authFilePath = path.join(__dirname, 'lib/auth.ts');
const authContent = fs.readFileSync(authFilePath, 'utf8');

if (authContent.includes('"fallback-secret"') || authContent.includes("'fallback-secret'")) {
  console.log("[FAIL] ✗ Source code still contains hardcoded 'fallback-secret'");
  process.exit(1);
} else {
  console.log("[PASS] ✓ Source code does not contain hardcoded 'fallback-secret'");
}

// Test 2: Check if validation is present
console.log("\n[TEST 2] Checking if JWT_SECRET validation is present...");
if (!authContent.includes('JWT_SECRET') || !authContent.includes('throw new Error')) {
  console.log("[FAIL] ✗ No JWT_SECRET validation found in auth.ts");
  process.exit(1);
} else {
  console.log("[PASS] ✓ JWT_SECRET validation is present in auth.ts");
}

// Test 3: Check for minimum length validation
console.log("\n[TEST 3] Checking if minimum length validation exists...");
if (!authContent.includes('32') && !authContent.includes('secret.length')) {
  console.log("[WARNING] ⚠ Minimum length validation not clearly visible");
} else {
  console.log("[PASS] ✓ Minimum length validation is present");
}

// Test 4: Try to create a token with the hardcoded fallback (should fail if vulnerability is fixed)
console.log("\n[TEST 4] Attempting to generate/verify token with fallback-secret...");
const fallbackSecret = "fallback-secret";
const testUser = { id: 999, email: "attacker@evil.com", role: "admin" };

try {
  // Try to generate a token with fallback secret
  const forgedToken = jwt.sign(testUser, fallbackSecret, { expiresIn: "24h" });
  console.log("[*] Generated forged token: " + forgedToken.substring(0, 50) + "...");
  
  // Try to verify with fallback secret
  const verified = jwt.verify(forgedToken, fallbackSecret);
  console.log("[FAIL] ✗ VULNERABILITY STILL EXISTS: Token with fallback-secret was verified successfully!");
  console.log("       Attacker can forge admin tokens using: " + fallbackSecret);
  process.exit(1);
} catch (err) {
  // If we can't verify, that's good - the vulnerability might be fixed
  console.log("[*] Could not verify token with fallback-secret (this is expected)");
}

// Test 5: Check instrumentation.ts for JWT validation
console.log("\n[TEST 5] Checking if JWT_SECRET is validated at startup...");
const instrumentationPath = path.join(__dirname, 'instrumentation.ts');
const instrumentationContent = fs.readFileSync(instrumentationPath, 'utf8');

if (instrumentationContent.includes('JWT_SECRET') && instrumentationContent.includes('throw new Error')) {
  console.log("[PASS] ✓ JWT_SECRET validation is present in instrumentation.ts");
} else {
  console.log("[WARNING] ⚠ JWT_SECRET startup validation might be missing");
}

console.log("\n[✓] All tests passed! The hardcoded fallback secret vulnerability appears to be fixed.");
console.log("\nSummary:");
console.log("  - Hardcoded 'fallback-secret' has been removed from source code");
console.log("  - JWT_SECRET validation is enforced");
console.log("  - Application will fail to start if JWT_SECRET is not properly configured");
process.exit(0);