diff --git a/test-jwt-vulnerability.js b/test-jwt-vulnerability.js
new file mode 100644
index 0000000..9b86318
 * Test script to verify JWT fallback secret vulnerability is fixed
 * 
 * This script attempts to:
 * 1. Forge a JWT token using the known fallback secret "fallback-secret"
 * 2. Send it to the protected endpoint
 * 3. Verify that the token is REJECTED
 * 
 * SUCCESS = Vulnerability is FIXED (forged token is rejected)
 * FAILURE = Vulnerability still EXISTS (forged token is accepted)
 */

const jwt = require('jsonwebtoken');
const http = require('http');

// The fallback secret that was hardcoded
const FALLBACK_SECRET = 'fallback-secret';

// Create a forged admin token using the fallback secret
console.log('[TEST] Creating forged JWT token with fallback secret...');
const forgedToken = jwt.sign(
  { id: 999, email: 'attacker@evil.com', role: 'admin' },
  FALLBACK_SECRET,
  { expiresIn: '24h' }
);

console.log('[TEST] Forged token created:', forgedToken.substring(0, 50) + '...');

// Try to use this token to access protected endpoint
console.log('[TEST] Attempting to access /api/auth/me with forged token...');

const options = {
  hostname: 'localhost',
  port: 3000,
  path: '/api/auth/me',
  method: 'GET',
  headers: {
    'Cookie': `token=${forgedToken}`
  }
};

const req = http.request(options, (res) => {
  let data = '';
  
  res.on('data', (chunk) => {
    data += chunk;
  });
  
  res.on('end', () => {
    console.log('[TEST] Response status:', res.statusCode);
    console.log('[TEST] Response body:', data);
    
    try {
      const responseBody = JSON.parse(data);
      
      // Check if the request was successful (which would indicate vulnerability)
      if (res.statusCode === 200 && responseBody.id === 999) {
        console.error('[FAIL] ✗ VULNERABILITY STILL EXISTS!');
        console.error('[FAIL] Forged token was ACCEPTED by the server');
        console.error('[FAIL] Attacker successfully bypassed authentication');
        process.exit(0); // POC succeeds (vulnerability exists)
      } else if (res.statusCode === 401 || res.statusCode === 403) {
        console.log('[PASS] ✓ VULNERABILITY IS FIXED!');
        console.log('[PASS] Forged token was REJECTED by the server');
        console.log('[PASS] Authentication bypass is no longer possible');
        process.exit(1); // POC fails (vulnerability is fixed) - return non-zero
      } else {
        console.log('[INFO] Unexpected response:', res.statusCode);
        process.exit(0);
      }
    } catch (e) {
      // If response isn't JSON, check status code
      if (res.statusCode === 401 || res.statusCode === 403) {
        console.log('[PASS] ✓ VULNERABILITY IS FIXED!');
        console.log('[PASS] Forged token was REJECTED by the server');
        console.log('[PASS] Authentication bypass is no longer possible');
        process.exit(1);
      } else {
        console.error('[UNKNOWN] Could not parse response');
        process.exit(0);
      }
    }
  });
});

req.on('error', (e) => {
  console.error('[ERROR] Connection failed:', e.message);
  console.error('[ERROR] Is the server running on http://localhost:3000?');
  process.exit(0);
});

req.end();